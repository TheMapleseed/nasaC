{
  "code_sample": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n/* ARM Cortex-M specific optimizations and NASA compliance */\n#define ARM_STACK_ALIGN 8U\n#define ARM_STACK_SIZE 2048U\n#define ARM_CACHE_LINE_SIZE 32U\n\n/* ARM-specific memory barriers */\n#define ARM_DSB() __asm volatile(\"dsb 0xf\" : : : \"memory\")\n#define ARM_ISB() __asm volatile(\"isb 0xf\" : : : \"memory\")\n#define ARM_DMB() __asm volatile(\"dmb 0xf\" : : : \"memory\")\n\n/* ARM Cortex-M system control block structure */\ntypedef struct {\n    uint32_t cpuid;        /* CPU ID Base Register */\n    uint32_t icsr;         /* Interrupt Control State Register */\n    uint32_t vtor;         /* Vector Table Offset Register */\n    uint32_t aircr;        /* Application Interrupt and Reset Control Register */\n    uint32_t scr;          /* System Control Register */\n    uint32_t ccr;          /* Configuration Control Register */\n    uint32_t shpr1;        /* System Handler Priority Register 1 */\n    uint32_t shpr2;        /* System Handler Priority Register 2 */\n    uint32_t shpr3;        /* System Handler Priority Register 3 */\n    uint32_t shcsr;        /* System Handler Control and State Register */\n    uint32_t cfsr;         /* Configurable Fault Status Register */\n    uint32_t hfsr;         /* Hard Fault Status Register */\n    uint32_t dfsr;         /* Debug Fault Status Register */\n    uint32_t mmfar;        /* MemManage Fault Address Register */\n    uint32_t bfar;         /* Bus Fault Address Register */\n} arm_scb_t;\n\n/* ARM Cortex-M NVIC structure */\ntypedef struct {\n    uint32_t iser[8];      /* Interrupt Set-Enable Registers */\n    uint32_t icer[8];      /* Interrupt Clear-Enable Registers */\n    uint32_t ispr[8];      /* Interrupt Set-Pending Registers */\n    uint32_t icpr[8];      /* Interrupt Clear-Pending Registers */\n    uint32_t iabr[8];      /* Interrupt Active Bit Registers */\n    uint8_t ipr[240];      /* Interrupt Priority Registers */\n} arm_nvic_t;\n\n/* ARM Cortex-M SysTick structure */\ntypedef struct {\n    uint32_t ctrl;         /* SysTick Control and Status Register */\n    uint32_t reload;       /* SysTick Reload Value Register */\n    uint32_t current;      /* SysTick Current Value Register */\n    uint32_t calib;        /* SysTick Calibration Value Register */\n} arm_systick_t;\n\n/* ARM Cortex-M specific sensor data structure */\ntypedef struct {\n    uint16_t sensor_id;\n    uint32_t timestamp;    /* ARM SysTick timestamp */\n    int16_t temperature;   /* Temperature in 0.1°C units */\n    uint16_t pressure;     /* Pressure in 0.1 mbar units */\n    uint8_t humidity;      /* Humidity in 0.1% units */\n    bool is_valid;\n    uint8_t padding[2];    /* Padding for ARM alignment */\n} arm_sensor_data_t;\n\n/* ARM Cortex-M sensor array with bounds checking */\ntypedef struct {\n    arm_sensor_data_t sensors[16U];  /* Fixed size array - NASA Rule 3 */\n    uint8_t active_count;\n    uint32_t system_uptime;\n    bool system_healthy;\n    uint8_t padding[3];    /* ARM alignment padding */\n} arm_sensor_system_t;\n\n/* ARM Cortex-M stack with overflow protection */\ntypedef struct {\n    uint8_t data[ARM_STACK_SIZE];\n    uint32_t magic_start;  /* Magic number for overflow detection */\n    uint32_t magic_end;    /* Magic number for overflow detection */\n} arm_stack_t;\n\n/* Magic numbers for ARM stack overflow detection */\n#define ARM_STACK_MAGIC_START 0xDEADBEEFU\n#define ARM_STACK_MAGIC_END 0xCAFEBABEU\n\n/* ARM Cortex-M static memory pools */\n#define ARM_POOL_COUNT 3U\n#define ARM_POOL_0_SIZE 32U\n#define ARM_POOL_1_SIZE 64U\n#define ARM_POOL_2_SIZE 128U\n\n/* ARM memory pool structure */\ntypedef struct {\n    uint8_t* data;\n    uint16_t block_size;\n    uint16_t block_count;\n    bool* allocated;\n    uint16_t free_count;\n    uint8_t padding[2];    /* ARM alignment padding */\n} arm_memory_pool_t;\n\n/* ARM static memory pool data */\nstatic uint8_t arm_pool_0_data[ARM_POOL_0_SIZE * 8U] __attribute__((aligned(ARM_CACHE_LINE_SIZE)));\nstatic uint8_t arm_pool_1_data[ARM_POOL_1_SIZE * 4U] __attribute__((aligned(ARM_CACHE_LINE_SIZE)));\nstatic uint8_t arm_pool_2_data[ARM_POOL_2_SIZE * 2U] __attribute__((aligned(ARM_CACHE_LINE_SIZE)));\n\nstatic bool arm_pool_0_allocated[8U];\nstatic bool arm_pool_1_allocated[4U];\nstatic bool arm_pool_2_allocated[2U];\n\nstatic arm_memory_pool_t arm_memory_pools[ARM_POOL_COUNT];\n\n/* ARM Cortex-M system instances */\nstatic arm_sensor_system_t arm_sensor_system;\nstatic arm_stack_t arm_main_stack __attribute__((aligned(ARM_STACK_ALIGN)));\n\n/* ARM Cortex-M specific initialization */\nvoid arm_initialize_system(void) {\n    /* Initialize ARM stack with overflow protection */\n    arm_main_stack.magic_start = ARM_STACK_MAGIC_START;\n    arm_main_stack.magic_end = ARM_STACK_MAGIC_END;\n    \n    /* Initialize ARM sensor system */\n    memset(&arm_sensor_system, 0, sizeof(arm_sensor_system_t));\n    arm_sensor_system.system_healthy = true;\n    \n    /* Initialize ARM memory pools */\n    arm_memory_pools[0].data = arm_pool_0_data;\n    arm_memory_pools[0].block_size = ARM_POOL_0_SIZE;\n    arm_memory_pools[0].block_count = 8U;\n    arm_memory_pools[0].allocated = arm_pool_0_allocated;\n    arm_memory_pools[0].free_count = 8U;\n    \n    arm_memory_pools[1].data = arm_pool_1_data;\n    arm_memory_pools[1].block_size = ARM_POOL_1_SIZE;\n    arm_memory_pools[1].block_count = 4U;\n    arm_memory_pools[1].allocated = arm_pool_1_allocated;\n    arm_memory_pools[1].free_count = 4U;\n    \n    arm_memory_pools[2].data = arm_pool_2_data;\n    arm_memory_pools[2].block_size = ARM_POOL_2_SIZE;\n    arm_memory_pools[2].block_count = 2U;\n    arm_memory_pools[2].allocated = arm_pool_2_allocated;\n    arm_memory_pools[2].free_count = 2U;\n    \n    /* Initialize allocation flags */\n    for (uint16_t i = 0; i < 8U; i++) arm_pool_0_allocated[i] = false;\n    for (uint16_t i = 0; i < 4U; i++) arm_pool_1_allocated[i] = false;\n    for (uint16_t i = 0; i < 2U; i++) arm_pool_2_allocated[i] = false;\n    \n    /* ARM memory barriers for initialization */\n    ARM_DMB();\n    ARM_DSB();\n}\n\n/* ARM Cortex-M stack overflow detection */\nbool arm_check_stack_overflow(void) {\n    return (arm_main_stack.magic_start != ARM_STACK_MAGIC_START) ||\n           (arm_main_stack.magic_end != ARM_STACK_MAGIC_END);\n}\n\n/* ARM Cortex-M memory pool allocation */\nvoid* arm_allocate_from_pool(uint16_t size) {\n    for (uint16_t i = 0; i < ARM_POOL_COUNT; i++) {\n        if (size <= arm_memory_pools[i].block_size && \n            arm_memory_pools[i].free_count > 0) {\n            \n            arm_memory_pool_t* pool = &arm_memory_pools[i];\n            \n            /* Find free block */\n            for (uint16_t j = 0; j < pool->block_count; j++) {\n                if (!pool->allocated[j]) {\n                    pool->allocated[j] = true;\n                    pool->free_count--;\n                    \n                    /* ARM cache operations */\n                    ARM_DMB();\n                    \n                    return pool->data + (j * pool->block_size);\n                }\n            }\n        }\n    }\n    \n    return NULL;  /* No suitable pool */\n}\n\n/* ARM Cortex-M memory pool release */\nbool arm_release_to_pool(void* ptr) {\n    if (ptr == NULL) {\n        return false;\n    }\n    \n    /* Find which pool this pointer belongs to */\n    for (uint16_t i = 0; i < ARM_POOL_COUNT; i++) {\n        arm_memory_pool_t* pool = &arm_memory_pools[i];\n        \n        if (ptr >= pool->data && \n            ptr < pool->data + (pool->block_count * pool->block_size)) {\n            \n            /* Calculate block index */\n            uint16_t block_index = ((uint8_t*)ptr - pool->data) / pool->block_size;\n            \n            if (block_index < pool->block_count && pool->allocated[block_index]) {\n                pool->allocated[block_index] = false;\n                pool->free_count++;\n                \n                /* ARM memory barriers */\n                ARM_DMB();\n                \n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\n/* ARM Cortex-M sensor data validation */\nbool arm_validate_sensor_data(const arm_sensor_data_t* sensor) {\n    if (sensor == NULL) {\n        return false;\n    }\n    \n    /* Validate sensor ID range */\n    if (sensor->sensor_id >= 16U) {\n        return false;\n    }\n    \n    /* Validate temperature range (-50°C to +150°C) */\n    if (sensor->temperature < -500 || sensor->temperature > 1500) {\n        return false;\n    }\n    \n    /* Validate pressure range (800-1200 mbar) */\n    if (sensor->pressure < 8000 || sensor->pressure > 12000) {\n        return false;\n    }\n    \n    /* Validate humidity range (0-100%) */\n    if (sensor->humidity > 1000) {\n        return false;\n    }\n    \n    return true;\n}\n\n/* ARM Cortex-M sensor data processing with bounds checking */\nbool arm_process_sensor_data(uint8_t sensor_index, const arm_sensor_data_t* new_data) {\n    if (sensor_index >= 16U || new_data == NULL) {\n        return false;\n    }\n    \n    if (!arm_validate_sensor_data(new_data)) {\n        return false;\n    }\n    \n    /* Update sensor data with ARM-specific optimizations */\n    arm_sensor_system.sensors[sensor_index] = *new_data;\n    arm_sensor_system.sensors[sensor_index].timestamp = arm_sensor_system.system_uptime;\n    \n    /* ARM memory barriers for data consistency */\n    ARM_DMB();\n    \n    /* Update system health based on sensor validity */\n    if (new_data->is_valid) {\n        arm_sensor_system.active_count++;\n    } else {\n        arm_sensor_system.active_count--;\n    }\n    \n    /* Check system health threshold */\n    if (arm_sensor_system.active_count < 8U) {\n        arm_sensor_system.system_healthy = false;\n    } else {\n        arm_sensor_system.system_healthy = true;\n    }\n    \n    return true;\n}\n\n/* ARM Cortex-M sensor array processing with bounded loops */\nvoid arm_process_all_sensors(void) {\n    uint8_t processed_count = 0U;\n    uint8_t index = 0U;\n    \n    /* Bounded loop with explicit counter - NASA Rule 2 */\n    while (index < 16U && processed_count < 16U) {\n        if (arm_sensor_system.sensors[index].is_valid) {\n            /* Process valid sensor data */\n            arm_sensor_data_t* sensor = &arm_sensor_system.sensors[index];\n            \n            /* Check for critical sensor readings */\n            if (sensor->temperature > 1000) {  /* > 100°C */\n                /* Handle high temperature condition */\n                handle_high_temperature(sensor->sensor_id, sensor->temperature);\n            }\n            \n            if (sensor->pressure < 9000 || sensor->pressure > 11000) {\n                /* Handle pressure anomaly */\n                handle_pressure_anomaly(sensor->sensor_id, sensor->pressure);\n            }\n            \n            processed_count++;\n        }\n        \n        index++;\n    }\n    \n    /* Update system uptime */\n    arm_sensor_system.system_uptime++;\n}\n\n/* ARM Cortex-M interrupt-safe operations */\nvoid arm_interrupt_safe_operation(void) {\n    /* Disable interrupts for critical section */\n    uint32_t primask = __get_PRIMASK();\n    __disable_irq();\n    \n    /* Critical section - update shared data */\n    arm_sensor_system.system_uptime++;\n    \n    /* ARM memory barriers for interrupt safety */\n    ARM_DMB();\n    ARM_DSB();\n    \n    /* Restore interrupt state */\n    if (!primask) {\n        __enable_irq();\n    }\n}\n\n/* ARM Cortex-M cache operations */\nvoid arm_cache_operations(void) {\n    /* Clean cache line */\n    for (uint32_t addr = (uint32_t)&arm_sensor_system; \n         addr < (uint32_t)&arm_sensor_system + sizeof(arm_sensor_system_t); \n         addr += ARM_CACHE_LINE_SIZE) {\n        \n        /* ARM Cortex-M cache clean operation */\n        __asm volatile(\"dc civac, %0\" : : \"r\"(addr) : \"memory\");\n    }\n    \n    /* Data synchronization barrier */\n    ARM_DSB();\n    \n    /* Instruction synchronization barrier */\n    ARM_ISB();\n}\n\n/* ARM Cortex-M system health monitoring */\nbool arm_check_system_health(void) {\n    /* Check stack overflow */\n    if (arm_check_stack_overflow()) {\n        return false;\n    }\n    \n    /* Check sensor system health */\n    if (!arm_sensor_system.system_healthy) {\n        return false;\n    }\n    \n    /* Check memory pool health */\n    for (uint16_t i = 0; i < ARM_POOL_COUNT; i++) {\n        if (arm_memory_pools[i].free_count == 0) {\n            return false;  /* All pools exhausted */\n        }\n    }\n    \n    return true;\n}\n\n/* ARM Cortex-M main function with NASA compliance */\nint main(void) {\n    /* Initialize ARM Cortex-M system */\n    arm_initialize_system();\n    \n    /* Check initial system health */\n    if (!arm_check_system_health()) {\n        return -1;  /* System initialization failed */\n    }\n    \n    /* Main system loop with bounded execution */\n    uint32_t loop_count = 0U;\n    const uint32_t MAX_LOOPS = 1000000U;  /* NASA Rule 2: Fixed upper bound */\n    \n    while (loop_count < MAX_LOOPS) {\n        /* Process all sensors */\n        arm_process_all_sensors();\n        \n        /* Check system health periodically */\n        if (loop_count % 1000U == 0) {\n            if (!arm_check_system_health()) {\n                break;  /* Exit on health failure */\n            }\n        }\n        \n        /* Interrupt-safe operations */\n        arm_interrupt_safe_operation();\n        \n        /* Cache operations */\n        arm_cache_operations();\n        \n        loop_count++;\n    }\n    \n    return (int)loop_count;\n}",
  "compliance_score": 99,
  "compliance_level": "fully_compliant",
  "violations": [],
  "annotations": {
    "function_count": 12,
    "line_count": 320,
    "complexity_score": 6,
    "nesting_depth": 4,
    "variable_count": 25,
    "pointer_count": 12,
    "loop_count": 3,
    "conditional_count": 18
  },
  "tags": ["arm_cortex_m", "architecture_specific", "memory_pools", "cache_operations", "interrupt_safety"],
  "difficulty": "expert"
}
