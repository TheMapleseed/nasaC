{
  "code_sample": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n/* x86-64 specific optimizations and NASA compliance */\n#define X86_64_STACK_ALIGN 16U\n#define X86_64_STACK_SIZE 16384U\n#define X86_64_CACHE_LINE_SIZE 64U\n\n/* x86-64 specific memory barriers */\n#define X86_64_MFENCE() __asm volatile(\"mfence\" : : : \"memory\")\n#define X86_64_SFENCE() __asm volatile(\"sfence\" : : : \"memory\")\n#define X86_64_LFENCE() __asm volatile(\"lfence\" : : : \"memory\")\n\n/* x86-64 specific registers structure */\ntypedef struct {\n    uint64_t rax;          /* 64-bit general purpose register A */\n    uint64_t rbx;          /* 64-bit general purpose register B */\n    uint64_t rcx;          /* 64-bit general purpose register C */\n    uint64_t rdx;          /* 64-bit general purpose register D */\n    uint64_t rsi;          /* 64-bit source index register */\n    uint64_t rdi;          /* 64-bit destination index register */\n    uint64_t rbp;          /* 64-bit base pointer register */\n    uint64_t rsp;          /* 64-bit stack pointer register */\n    uint64_t r8;           /* Additional general purpose registers */\n    uint64_t r9;\n    uint64_t r10;\n    uint64_t r11;\n    uint64_t r12;\n    uint64_t r13;\n    uint64_t r14;\n    uint64_t r15;\n} x86_64_registers_t;\n\n/* x86-64 control registers structure */\ntypedef struct {\n    uint64_t cr0;          /* Control Register 0 */\n    uint64_t cr1;          /* Control Register 1 (reserved) */\n    uint64_t cr2;          /* Control Register 2 (page fault linear address) */\n    uint64_t cr3;          /* Control Register 3 (page directory base) */\n    uint64_t cr4;          /* Control Register 4 */\n    uint64_t cr8;          /* Control Register 8 (task priority) */\n} x86_64_control_registers_t;\n\n/* x86-64 model specific registers structure */\ntypedef struct {\n    uint64_t efer;         /* Extended Feature Enable Register */\n    uint64_t star;         /* SYSCALL Target Address Register */\n    uint64_t lstar;        /* Long Mode SYSCALL Target Address Register */\n    uint64_t cstar;        /* Compatibility Mode SYSCALL Target Address Register */\n    uint64_t sfmask;       /* SYSCALL Flag Mask Register */\n} x86_64_msr_t;\n\n/* x86-64 sensor data structure with little-endian consideration */\ntypedef struct {\n    uint16_t sensor_id;    /* Little-endian format */\n    uint64_t timestamp;    /* x86-64 TSC timestamp */\n    int32_t temperature;   /* Temperature in 0.01Â°C units */\n    uint32_t pressure;     /* Pressure in 0.01 mbar units */\n    uint16_t humidity;     /* Humidity in 0.01% units */\n    bool is_valid;\n    uint8_t padding[5];    /* x86-64 alignment padding */\n} x86_64_sensor_data_t __attribute__((aligned(X86_64_CACHE_LINE_SIZE)));\n\n/* x86-64 sensor array with bounds checking */\ntypedef struct {\n    x86_64_sensor_data_t sensors[64U];  /* Fixed size array - NASA Rule 3 */\n    uint16_t active_count;\n    uint64_t system_uptime;\n    bool system_healthy;\n    uint8_t padding[5];    /* x86-64 alignment padding */\n} x86_64_sensor_system_t __attribute__((aligned(X86_64_CACHE_LINE_SIZE)));\n\n/* x86-64 stack with overflow protection */\ntypedef struct {\n    uint8_t data[X86_64_STACK_SIZE];\n    uint64_t magic_start;  /* Magic number for overflow detection */\n    uint64_t magic_end;    /* Magic number for overflow detection */\n} x86_64_stack_t;\n\n/* Magic numbers for x86-64 stack overflow detection */\n#define X86_64_STACK_MAGIC_START 0xDEADBEEFCAFEBABEULL\n#define X86_64_STACK_MAGIC_END 0xCAFEBABEDEADBEEFULL\n\n/* x86-64 static memory pools with cache line alignment */\n#define X86_64_POOL_COUNT 5U\n#define X86_64_POOL_0_SIZE 64U\n#define X86_64_POOL_1_SIZE 128U\n#define X86_64_POOL_2_SIZE 256U\n#define X86_64_POOL_3_SIZE 512U\n#define X86_64_POOL_4_SIZE 1024U\n\n/* x86-64 memory pool structure */\ntypedef struct {\n    uint8_t* data;\n    uint32_t block_size;\n    uint32_t block_count;\n    bool* allocated;\n    uint32_t free_count;\n    uint8_t padding[4];    /* x86-64 alignment padding */\n} x86_64_memory_pool_t;\n\n/* x86-64 static memory pool data with cache line alignment */\nstatic uint8_t x86_64_pool_0_data[X86_64_POOL_0_SIZE * 32U] __attribute__((aligned(X86_64_CACHE_LINE_SIZE)));\nstatic uint8_t x86_64_pool_1_data[X86_64_POOL_1_SIZE * 16U] __attribute__((aligned(X86_64_CACHE_LINE_SIZE)));\nstatic uint8_t x86_64_pool_2_data[X86_64_POOL_2_SIZE * 8U] __attribute__((aligned(X86_64_CACHE_LINE_SIZE)));\nstatic uint8_t x86_64_pool_3_data[X86_64_POOL_3_SIZE * 4U] __attribute__((aligned(X86_64_CACHE_LINE_SIZE)));\nstatic uint8_t x86_64_pool_4_data[X86_64_POOL_4_SIZE * 2U] __attribute__((aligned(X86_64_CACHE_LINE_SIZE)));\n\nstatic bool x86_64_pool_0_allocated[32U];\nstatic bool x86_64_pool_1_allocated[16U];\nstatic bool x86_64_pool_2_allocated[8U];\nstatic bool x86_64_pool_3_allocated[4U];\nstatic bool x86_64_pool_4_allocated[2U];\n\nstatic x86_64_memory_pool_t x86_64_memory_pools[X86_64_POOL_COUNT];\n\n/* x86-64 system instances */\nstatic x86_64_sensor_system_t x86_64_sensor_system;\nstatic x86_64_stack_t x86_64_main_stack __attribute__((aligned(X86_64_STACK_ALIGN)));\n\n/* x86-64 endianness handling for little-endian systems */\nstatic inline uint16_t x86_64_read_16_le(const uint8_t* data) {\n    return (uint16_t)(data[0] | (data[1] << 8));\n}\n\nstatic inline uint32_t x86_64_read_32_le(const uint8_t* data) {\n    return (uint32_t)(data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24));\n}\n\nstatic inline uint64_t x86_64_read_64_le(const uint8_t* data) {\n    return (uint64_t)(data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24) |\n                      ((uint64_t)data[4] << 32) | ((uint64_t)data[5] << 40) |\n                      ((uint64_t)data[6] << 48) | ((uint64_t)data[7] << 56));\n}\n\nstatic inline void x86_64_write_16_le(uint8_t* data, uint16_t value) {\n    data[0] = (uint8_t)(value & 0xFF);\n    data[1] = (uint8_t)(value >> 8);\n}\n\nstatic inline void x86_64_write_32_le(uint8_t* data, uint32_t value) {\n    data[0] = (uint8_t)(value & 0xFF);\n    data[1] = (uint8_t)((value >> 8) & 0xFF);\n    data[2] = (uint8_t)((value >> 16) & 0xFF);\n    data[3] = (uint8_t)((value >> 24) & 0xFF);\n}\n\nstatic inline void x86_64_write_64_le(uint8_t* data, uint64_t value) {\n    data[0] = (uint8_t)(value & 0xFF);\n    data[1] = (uint8_t)((value >> 8) & 0xFF);\n    data[2] = (uint8_t)((value >> 16) & 0xFF);\n    data[3] = (uint8_t)((value >> 24) & 0xFF);\n    data[4] = (uint8_t)((value >> 32) & 0xFF);\n    data[5] = (uint8_t)((value >> 40) & 0xFF);\n    data[6] = (uint8_t)((value >> 48) & 0xFF);\n    data[7] = (uint8_t)((value >> 56) & 0xFF);\n}\n\n/* x86-64 specific initialization */\nvoid x86_64_initialize_system(void) {\n    /* Initialize x86-64 stack with overflow protection */\n    x86_64_main_stack.magic_start = X86_64_STACK_MAGIC_START;\n    x86_64_main_stack.magic_end = X86_64_STACK_MAGIC_END;\n    \n    /* Initialize x86-64 sensor system */\n    memset(&x86_64_sensor_system, 0, sizeof(x86_64_sensor_system_t));\n    x86_64_sensor_system.system_healthy = true;\n    \n    /* Initialize x86-64 memory pools */\n    x86_64_memory_pools[0].data = x86_64_pool_0_data;\n    x86_64_memory_pools[0].block_size = X86_64_POOL_0_SIZE;\n    x86_64_memory_pools[0].block_count = 32U;\n    x86_64_memory_pools[0].allocated = x86_64_pool_0_allocated;\n    x86_64_memory_pools[0].free_count = 32U;\n    \n    x86_64_memory_pools[1].data = x86_64_pool_1_data;\n    x86_64_memory_pools[1].block_size = X86_64_POOL_1_SIZE;\n    x86_64_memory_pools[1].block_count = 16U;\n    x86_64_memory_pools[1].allocated = x86_64_pool_1_allocated;\n    x86_64_memory_pools[1].free_count = 16U;\n    \n    x86_64_memory_pools[2].data = x86_64_pool_2_data;\n    x86_64_memory_pools[2].block_size = X86_64_POOL_2_SIZE;\n    x86_64_memory_pools[2].block_count = 8U;\n    x86_64_memory_pools[2].allocated = x86_64_pool_2_allocated;\n    x86_64_memory_pools[2].free_count = 8U;\n    \n    x86_64_memory_pools[3].data = x86_64_pool_3_data;\n    x86_64_memory_pools[3].block_size = X86_64_POOL_3_SIZE;\n    x86_64_memory_pools[3].block_count = 4U;\n    x86_64_memory_pools[3].allocated = x86_64_pool_3_allocated;\n    x86_64_memory_pools[3].free_count = 4U;\n    \n    x86_64_memory_pools[4].data = x86_64_pool_4_data;\n    x86_64_memory_pools[4].block_size = X86_64_POOL_4_SIZE;\n    x86_64_memory_pools[4].block_count = 2U;\n    x86_64_memory_pools[4].allocated = x86_64_pool_4_allocated;\n    x86_64_memory_pools[4].free_count = 2U;\n    \n    /* Initialize allocation flags */\n    for (uint32_t i = 0; i < 32U; i++) x86_64_pool_0_allocated[i] = false;\n    for (uint32_t i = 0; i < 16U; i++) x86_64_pool_1_allocated[i] = false;\n    for (uint32_t i = 0; i < 8U; i++) x86_64_pool_2_allocated[i] = false;\n    for (uint32_t i = 0; i < 4U; i++) x86_64_pool_3_allocated[i] = false;\n    for (uint32_t i = 0; i < 2U; i++) x86_64_pool_4_allocated[i] = false;\n    \n    /* x86-64 memory barriers for initialization */\n    X86_64_MFENCE();\n    X86_64_SFENCE();\n    X86_64_LFENCE();\n}\n\n/* x86-64 stack overflow detection */\nbool x86_64_check_stack_overflow(void) {\n    return (x86_64_main_stack.magic_start != X86_64_STACK_MAGIC_START) ||\n           (x86_64_main_stack.magic_end != X86_64_STACK_MAGIC_END);\n}\n\n/* x86-64 memory pool allocation */\nvoid* x86_64_allocate_from_pool(uint32_t size) {\n    for (uint32_t i = 0; i < X86_64_POOL_COUNT; i++) {\n        if (size <= x86_64_memory_pools[i].block_size && \n            x86_64_memory_pools[i].free_count > 0) {\n            \n            x86_64_memory_pool_t* pool = &x86_64_memory_pools[i];\n            \n            /* Find free block */\n            for (uint32_t j = 0; j < pool->block_count; j++) {\n                if (!pool->allocated[j]) {\n                    pool->allocated[j] = true;\n                    pool->free_count--;\n                    \n                    /* x86-64 cache operations */\n                    void* block_ptr = pool->data + (j * pool->block_size);\n                    __asm volatile(\"clflush [%0]\" : : \"r\"(block_ptr) : \"memory\");\n                    \n                    return block_ptr;\n                }\n            }\n        }\n    }\n    \n    return NULL;  /* No suitable pool */\n}\n\n/* x86-64 memory pool release */\nbool x86_64_release_to_pool(void* ptr) {\n    if (ptr == NULL) {\n        return false;\n    }\n    \n    /* Find which pool this pointer belongs to */\n    for (uint32_t i = 0; i < X86_64_POOL_COUNT; i++) {\n        x86_64_memory_pool_t* pool = &x86_64_memory_pools[i];\n        \n        if (ptr >= pool->data && \n            ptr < pool->data + (pool->block_count * pool->block_size)) {\n            \n            /* Calculate block index */\n            uint32_t block_index = ((uint8_t*)ptr - pool->data) / pool->block_size;\n            \n            if (block_index < pool->block_count && pool->allocated[block_index]) {\n                pool->allocated[block_index] = false;\n                pool->free_count++;\n                \n                /* x86-64 memory barriers */\n                X86_64_MFENCE();\n                \n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\n/* x86-64 sensor data validation with endianness handling */\nbool x86_64_validate_sensor_data(const x86_64_sensor_data_t* sensor) {\n    if (sensor == NULL) {\n        return false;\n    }\n    \n    /* Validate sensor ID range */\n    if (sensor->sensor_id >= 64U) {\n        return false;\n    }\n    \n    /* Validate temperature range (-50Â°C to +150Â°C) */\n    if (sensor->temperature < -5000 || sensor->temperature > 15000) {\n        return false;\n    }\n    \n    /* Validate pressure range (800-1200 mbar) */\n    if (sensor->pressure < 80000 || sensor->pressure > 120000) {\n        return false;\n    }\n    \n    /* Validate humidity range (0-100%) */\n    if (sensor->humidity > 10000) {\n        return false;\n    }\n    \n    return true;\n}\n\n/* x86-64 sensor data processing with bounds checking */\nbool x86_64_process_sensor_data(uint16_t sensor_index, const x86_64_sensor_data_t* new_data) {\n    if (sensor_index >= 64U || new_data == NULL) {\n        return false;\n    }\n    \n    if (!x86_64_validate_sensor_data(new_data)) {\n        return false;\n    }\n    \n    /* Update sensor data with x86-64-specific optimizations */\n    x86_64_sensor_system.sensors[sensor_index] = *new_data;\n    x86_64_sensor_system.sensors[sensor_index].timestamp = x86_64_sensor_system.system_uptime;\n    \n    /* x86-64 memory barriers for data consistency */\n    X86_64_MFENCE();\n    \n    /* Update system health based on sensor validity */\n    if (new_data->is_valid) {\n        x86_64_sensor_system.active_count++;\n    } else {\n        x86_64_sensor_system.active_count--;\n    }\n    \n    /* Check system health threshold */\n    if (x86_64_sensor_system.active_count < 32U) {\n        x86_64_sensor_system.system_healthy = false;\n    } else {\n        x86_64_sensor_system.system_healthy = true;\n    }\n    \n    return true;\n}\n\n/* x86-64 sensor array processing with bounded loops */\nvoid x86_64_process_all_sensors(void) {\n    uint16_t processed_count = 0U;\n    uint16_t index = 0U;\n    \n    /* Bounded loop with explicit counter - NASA Rule 2 */\n    while (index < 64U && processed_count < 64U) {\n        if (x86_64_sensor_system.sensors[index].is_valid) {\n            /* Process valid sensor data */\n            x86_64_sensor_data_t* sensor = &x86_64_sensor_system.sensors[index];\n            \n            /* Check for critical sensor readings */\n            if (sensor->temperature > 10000) {  /* > 100Â°C */\n                /* Handle high temperature condition */\n                x86_64_handle_high_temperature(sensor->sensor_id, sensor->temperature);\n            }\n            \n            if (sensor->pressure < 90000 || sensor->pressure > 110000) {\n                /* Handle pressure anomaly */\n                x86_64_handle_pressure_anomaly(sensor->sensor_id, sensor->pressure);\n            }\n            \n            processed_count++;\n        }\n        \n        index++;\n    }\n    \n    /* Update system uptime */\n    x86_64_sensor_system.system_uptime++;\n}\n\n/* x86-64 interrupt-safe operations */\nvoid x86_64_interrupt_safe_operation(void) {\n    /* Disable interrupts for critical section */\n    uint64_t rflags = __get_RFLAGS();\n    __disable_interrupts();\n    \n    /* Critical section - update shared data */\n    x86_64_sensor_system.system_uptime++;\n    \n    /* x86-64 memory barriers for interrupt safety */\n    X86_64_MFENCE();\n    X86_64_SFENCE();\n    X86_64_LFENCE();\n    \n    /* Restore interrupt state */\n    __set_RFLAGS(rflags);\n}\n\n/* x86-64 cache operations */\nvoid x86_64_cache_operations(void) {\n    /* Clean cache lines for sensor system */\n    for (uint64_t addr = (uint64_t)&x86_64_sensor_system; \n         addr < (uint64_t)&x86_64_sensor_system + sizeof(x86_64_sensor_system_t); \n         addr += X86_64_CACHE_LINE_SIZE) {\n        \n        /* x86-64 cache clean operation */\n        __asm volatile(\"clflush [%0]\" : : \"r\"(addr) : \"memory\");\n    }\n    \n    /* Synchronize cache operations */\n    X86_64_MFENCE();\n    \n    /* Instruction synchronization barrier */\n    X86_64_LFENCE();\n}\n\n/* x86-64 prefetch operations */\nvoid x86_64_prefetch_operations(void) {\n    /* Prefetch next sensor data for better cache performance */\n    for (uint16_t i = 0; i < 64U; i += 4U) {\n        if (i < 64U) {\n            /* Prefetch next cache line */\n            __asm volatile(\"prefetchnta [%0]\" : : \"r\"(&x86_64_sensor_system.sensors[i]) : \"memory\");\n        }\n    }\n    \n    /* Memory fence after prefetch operations */\n    X86_64_SFENCE();\n}\n\n/* x86-64 system health monitoring */\nbool x86_64_check_system_health(void) {\n    /* Check stack overflow */\n    if (x86_64_check_stack_overflow()) {\n        return false;\n    }\n    \n    /* Check sensor system health */\n    if (!x86_64_sensor_system.system_healthy) {\n        return false;\n    }\n    \n    /* Check memory pool health */\n    for (uint32_t i = 0; i < X86_64_POOL_COUNT; i++) {\n        if (x86_64_memory_pools[i].free_count == 0) {\n            return false;  /* All pools exhausted */\n        }\n    }\n    \n    return true;\n}\n\n/* x86-64 main function with NASA compliance */\nint main(void) {\n    /* Initialize x86-64 system */\n    x86_64_initialize_system();\n    \n    /* Check initial system health */\n    if (!x86_64_check_system_health()) {\n        return -1;  /* System initialization failed */\n    }\n    \n    /* Main system loop with bounded execution */\n    uint64_t loop_count = 0U;\n    const uint64_t MAX_LOOPS = 1000000ULL;  /* NASA Rule 2: Fixed upper bound */\n    \n    while (loop_count < MAX_LOOPS) {\n        /* Process all sensors */\n        x86_64_process_all_sensors();\n        \n        /* Check system health periodically */\n        if (loop_count % 1000ULL == 0) {\n            if (!x86_64_check_system_health()) {\n                break;  /* Exit on health failure */\n            }\n        }\n        \n        /* Interrupt-safe operations */\n        x86_64_interrupt_safe_operation();\n        \n        /* Cache operations */\n        x86_64_cache_operations();\n        \n        /* Prefetch operations */\n        x86_64_prefetch_operations();\n        \n        loop_count++;\n    }\n    \n    return (int)loop_count;\n}",
  "compliance_score": 99,
  "compliance_level": "fully_compliant",
  "violations": [],
  "annotations": {
    "function_count": 18,
    "line_count": 420,
    "complexity_score": 8,
    "nesting_depth": 4,
    "variable_count": 35,
    "pointer_count": 18,
    "loop_count": 5,
    "conditional_count": 25
  },
  "tags": ["x86_64", "architecture_specific", "little_endian", "memory_pools", "cache_operations", "prefetch"],
  "difficulty": "expert"
}
