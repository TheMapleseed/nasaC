{
  "code_sample": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n/* PowerPC e500 specific optimizations and NASA compliance */\n#define PPC_STACK_ALIGN 16U\n#define PPC_STACK_SIZE 4096U\n#define PPC_CACHE_LINE_SIZE 64U\n\n/* PowerPC-specific memory barriers */\n#define PPC_SYNC() __asm volatile(\"sync\" : : : \"memory\")\n#define PPC_ISYNC() __asm volatile(\"isync\" : : : \"memory\")\n#define PPC_EIEIO() __asm volatile(\"eieio\" : : : \"memory\")\n\n/* PowerPC e500 specific registers */\ntypedef struct {\n    uint32_t msr;          /* Machine State Register */\n    uint32_t ctr;          /* Count Register */\n    uint32_t lr;           /* Link Register */\n    uint32_t xer;          /* Fixed-Point Exception Register */\n    uint32_t sprg0;        /* Special Purpose Register 0 */\n    uint32_t sprg1;        /* Special Purpose Register 1 */\n    uint32_t sprg2;        /* Special Purpose Register 2 */\n    uint32_t sprg3;        /* Special Purpose Register 3 */\n} ppc_registers_t;\n\n/* PowerPC e500 cache control structure */\ntypedef struct {\n    uint32_t l1csr0;       /* L1 Cache Control and Status Register 0 */\n    uint32_t l1csr1;       /* L1 Cache Control and Status Register 1 */\n    uint32_t l1csr2;       /* L1 Cache Control and Status Register 2 */\n    uint32_t l1csr3;       /* L1 Cache Control and Status Register 3 */\n} ppc_cache_control_t;\n\n/* PowerPC e500 TLB structure */\ntypedef struct {\n    uint32_t mas0;         /* MMU Assist Register 0 */\n    uint32_t mas1;         /* MMU Assist Register 1 */\n    uint32_t mas2;         /* MMU Assist Register 2 */\n    uint32_t mas3;         /* MMU Assist Register 3 */\n    uint32_t mas4;         /* MMU Assist Register 4 */\n    uint32_t mas5;         /* MMU Assist Register 5 */\n    uint32_t mas6;         /* MMU Assist Register 6 */\n    uint32_t mas7;         /* MMU Assist Register 7 */\n} ppc_tlb_t;\n\n/* PowerPC e500 sensor data structure with big-endian consideration */\ntypedef struct {\n    uint16_t sensor_id;    /* Big-endian format */\n    uint32_t timestamp;    /* PowerPC timebase timestamp */\n    int16_t temperature;   /* Temperature in 0.1°C units */\n    uint16_t pressure;     /* Pressure in 0.1 mbar units */\n    uint8_t humidity;      /* Humidity in 0.1% units */\n    bool is_valid;\n    uint8_t padding[2];    /* PowerPC alignment padding */\n} ppc_sensor_data_t;\n\n/* PowerPC e500 sensor array with bounds checking */\ntypedef struct {\n    ppc_sensor_data_t sensors[32U];  /* Fixed size array - NASA Rule 3 */\n    uint8_t active_count;\n    uint32_t system_uptime;\n    bool system_healthy;\n    uint8_t padding[3];    /* PowerPC alignment padding */\n} ppc_sensor_system_t;\n\n/* PowerPC e500 stack with overflow protection */\ntypedef struct {\n    uint8_t data[PPC_STACK_SIZE];\n    uint32_t magic_start;  /* Magic number for overflow detection */\n    uint32_t magic_end;    /* Magic number for overflow detection */\n} ppc_stack_t;\n\n/* Magic numbers for PowerPC stack overflow detection */\n#define PPC_STACK_MAGIC_START 0xDEADBEEFU\n#define PPC_STACK_MAGIC_END 0xCAFEBABEU\n\n/* PowerPC e500 static memory pools with cache line alignment */\n#define PPC_POOL_COUNT 4U\n#define PPC_POOL_0_SIZE 64U\n#define PPC_POOL_1_SIZE 128U\n#define PPC_POOL_2_SIZE 256U\n#define PPC_POOL_3_SIZE 512U\n\n/* PowerPC memory pool structure */\ntypedef struct {\n    uint8_t* data;\n    uint16_t block_size;\n    uint16_t block_count;\n    bool* allocated;\n    uint16_t free_count;\n    uint8_t padding[2];    /* PowerPC alignment padding */\n} ppc_memory_pool_t;\n\n/* PowerPC static memory pool data with cache line alignment */\nstatic uint8_t ppc_pool_0_data[PPC_POOL_0_SIZE * 16U] __attribute__((aligned(PPC_CACHE_LINE_SIZE)));\nstatic uint8_t ppc_pool_1_data[PPC_POOL_1_SIZE * 8U] __attribute__((aligned(PPC_CACHE_LINE_SIZE)));\nstatic uint8_t ppc_pool_2_data[PPC_POOL_2_SIZE * 4U] __attribute__((aligned(PPC_CACHE_LINE_SIZE)));\nstatic uint8_t ppc_pool_3_data[PPC_POOL_3_SIZE * 2U] __attribute__((aligned(PPC_CACHE_LINE_SIZE)));\n\nstatic bool ppc_pool_0_allocated[16U];\nstatic bool ppc_pool_1_allocated[8U];\nstatic bool ppc_pool_2_allocated[4U];\nstatic bool ppc_pool_3_allocated[2U];\n\nstatic ppc_memory_pool_t ppc_memory_pools[PPC_POOL_COUNT];\n\n/* PowerPC e500 system instances */\nstatic ppc_sensor_system_t ppc_sensor_system;\nstatic ppc_stack_t ppc_main_stack __attribute__((aligned(PPC_STACK_ALIGN)));\n\n/* PowerPC e500 endianness handling */\nstatic inline uint16_t ppc_read_16_be(const uint8_t* data) {\n    return (uint16_t)((data[0] << 8) | data[1]);\n}\n\nstatic inline uint32_t ppc_read_32_be(const uint8_t* data) {\n    return (uint32_t)((data[0] << 24) | (data[1] << 16) | (data[2] << 8) | data[3]);\n}\n\nstatic inline void ppc_write_16_be(uint8_t* data, uint16_t value) {\n    data[0] = (uint8_t)(value >> 8);\n    data[1] = (uint8_t)(value & 0xFF);\n}\n\nstatic inline void ppc_write_32_be(uint8_t* data, uint32_t value) {\n    data[0] = (uint8_t)(value >> 24);\n    data[1] = (uint8_t)((value >> 16) & 0xFF);\n    data[2] = (uint8_t)((value >> 8) & 0xFF);\n    data[3] = (uint8_t)(value & 0xFF);\n}\n\n/* PowerPC e500 specific initialization */\nvoid ppc_initialize_system(void) {\n    /* Initialize PowerPC stack with overflow protection */\n    ppc_main_stack.magic_start = PPC_STACK_MAGIC_START;\n    ppc_main_stack.magic_end = PPC_STACK_MAGIC_END;\n    \n    /* Initialize PowerPC sensor system */\n    memset(&ppc_sensor_system, 0, sizeof(ppc_sensor_system_t));\n    ppc_sensor_system.system_healthy = true;\n    \n    /* Initialize PowerPC memory pools */\n    ppc_memory_pools[0].data = ppc_pool_0_data;\n    ppc_memory_pools[0].block_size = PPC_POOL_0_SIZE;\n    ppc_memory_pools[0].block_count = 16U;\n    ppc_memory_pools[0].allocated = ppc_pool_0_allocated;\n    ppc_memory_pools[0].free_count = 16U;\n    \n    ppc_memory_pools[1].data = ppc_pool_1_data;\n    ppc_memory_pools[1].block_size = PPC_POOL_1_SIZE;\n    ppc_memory_pools[1].block_count = 8U;\n    ppc_memory_pools[1].allocated = ppc_pool_1_allocated;\n    ppc_memory_pools[1].free_count = 8U;\n    \n    ppc_memory_pools[2].data = ppc_pool_2_data;\n    ppc_memory_pools[2].block_size = PPC_POOL_2_SIZE;\n    ppc_memory_pools[2].block_count = 4U;\n    ppc_memory_pools[2].allocated = ppc_pool_2_allocated;\n    ppc_memory_pools[2].free_count = 4U;\n    \n    ppc_memory_pools[3].data = ppc_pool_3_data;\n    ppc_memory_pools[3].block_size = PPC_POOL_3_SIZE;\n    ppc_memory_pools[3].block_count = 2U;\n    ppc_memory_pools[3].allocated = ppc_pool_3_allocated;\n    ppc_memory_pools[3].free_count = 2U;\n    \n    /* Initialize allocation flags */\n    for (uint16_t i = 0; i < 16U; i++) ppc_pool_0_allocated[i] = false;\n    for (uint16_t i = 0; i < 8U; i++) ppc_pool_1_allocated[i] = false;\n    for (uint16_t i = 0; i < 4U; i++) ppc_pool_2_allocated[i] = false;\n    for (uint16_t i = 0; i < 2U; i++) ppc_pool_3_allocated[i] = false;\n    \n    /* PowerPC memory barriers for initialization */\n    PPC_SYNC();\n    PPC_ISYNC();\n}\n\n/* PowerPC e500 stack overflow detection */\nbool ppc_check_stack_overflow(void) {\n    return (ppc_main_stack.magic_start != PPC_STACK_MAGIC_START) ||\n           (ppc_main_stack.magic_end != PPC_STACK_MAGIC_END);\n}\n\n/* PowerPC e500 memory pool allocation */\nvoid* ppc_allocate_from_pool(uint16_t size) {\n    for (uint16_t i = 0; i < PPC_POOL_COUNT; i++) {\n        if (size <= ppc_memory_pools[i].block_size && \n            ppc_memory_pools[i].free_count > 0) {\n            \n            ppc_memory_pool_t* pool = &ppc_memory_pools[i];\n            \n            /* Find free block */\n            for (uint16_t j = 0; j < pool->block_count; j++) {\n                if (!pool->allocated[j]) {\n                    pool->allocated[j] = true;\n                    pool->free_count--;\n                    \n                    /* PowerPC cache operations */\n                    PPC_DCBF(0, pool->data + (j * pool->block_size));\n                    \n                    return pool->data + (j * pool->block_size);\n                }\n            }\n        }\n    }\n    \n    return NULL;  /* No suitable pool */\n}\n\n/* PowerPC e500 memory pool release */\nbool ppc_release_to_pool(void* ptr) {\n    if (ptr == NULL) {\n        return false;\n    }\n    \n    /* Find which pool this pointer belongs to */\n    for (uint16_t i = 0; i < PPC_POOL_COUNT; i++) {\n        ppc_memory_pool_t* pool = &ppc_memory_pools[i];\n        \n        if (ptr >= pool->data && \n            ptr < pool->data + (pool->block_count * pool->block_size)) {\n            \n            /* Calculate block index */\n            uint16_t block_index = ((uint8_t*)ptr - pool->data) / pool->block_size;\n            \n            if (block_index < pool->block_count && pool->allocated[block_index]) {\n                pool->allocated[block_index] = false;\n                pool->free_count++;\n                \n                /* PowerPC memory barriers */\n                PPC_SYNC();\n                \n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\n/* PowerPC e500 sensor data validation with endianness handling */\nbool ppc_validate_sensor_data(const ppc_sensor_data_t* sensor) {\n    if (sensor == NULL) {\n        return false;\n    }\n    \n    /* Validate sensor ID range */\n    if (sensor->sensor_id >= 32U) {\n        return false;\n    }\n    \n    /* Validate temperature range (-50°C to +150°C) */\n    if (sensor->temperature < -500 || sensor->temperature > 1500) {\n        return false;\n    }\n    \n    /* Validate pressure range (800-1200 mbar) */\n    if (sensor->pressure < 8000 || sensor->pressure > 12000) {\n        return false;\n    }\n    \n    /* Validate humidity range (0-100%) */\n    if (sensor->humidity > 1000) {\n        return false;\n    }\n    \n    return true;\n}\n\n/* PowerPC e500 sensor data processing with bounds checking */\nbool ppc_process_sensor_data(uint8_t sensor_index, const ppc_sensor_data_t* new_data) {\n    if (sensor_index >= 32U || new_data == NULL) {\n        return false;\n    }\n    \n    if (!ppc_validate_sensor_data(new_data)) {\n        return false;\n    }\n    \n    /* Update sensor data with PowerPC-specific optimizations */\n    ppc_sensor_system.sensors[sensor_index] = *new_data;\n    ppc_sensor_system.sensors[sensor_index].timestamp = ppc_sensor_system.system_uptime;\n    \n    /* PowerPC memory barriers for data consistency */\n    PPC_SYNC();\n    \n    /* Update system health based on sensor validity */\n    if (new_data->is_valid) {\n        ppc_sensor_system.active_count++;\n    } else {\n        ppc_sensor_system.active_count--;\n    }\n    \n    /* Check system health threshold */\n    if (ppc_sensor_system.active_count < 16U) {\n        ppc_sensor_system.system_healthy = false;\n    } else {\n        ppc_sensor_system.system_healthy = true;\n    }\n    \n    return true;\n}\n\n/* PowerPC e500 sensor array processing with bounded loops */\nvoid ppc_process_all_sensors(void) {\n    uint8_t processed_count = 0U;\n    uint8_t index = 0U;\n    \n    /* Bounded loop with explicit counter - NASA Rule 2 */\n    while (index < 32U && processed_count < 32U) {\n        if (ppc_sensor_system.sensors[index].is_valid) {\n            /* Process valid sensor data */\n            ppc_sensor_data_t* sensor = &ppc_sensor_system.sensors[index];\n            \n            /* Check for critical sensor readings */\n            if (sensor->temperature > 1000) {  /* > 100°C */\n                /* Handle high temperature condition */\n                ppc_handle_high_temperature(sensor->sensor_id, sensor->temperature);\n            }\n            \n            if (sensor->pressure < 9000 || sensor->pressure > 11000) {\n                /* Handle pressure anomaly */\n                ppc_handle_pressure_anomaly(sensor->sensor_id, sensor->pressure);\n            }\n            \n            processed_count++;\n        }\n        \n        index++;\n    }\n    \n    /* Update system uptime */\n    ppc_sensor_system.system_uptime++;\n}\n\n/* PowerPC e500 interrupt-safe operations */\nvoid ppc_interrupt_safe_operation(void) {\n    /* Disable interrupts for critical section */\n    uint32_t msr = __get_MSR();\n    __disable_interrupts();\n    \n    /* Critical section - update shared data */\n    ppc_sensor_system.system_uptime++;\n    \n    /* PowerPC memory barriers for interrupt safety */\n    PPC_SYNC();\n    PPC_ISYNC();\n    \n    /* Restore interrupt state */\n    __set_MSR(msr);\n}\n\n/* PowerPC e500 cache operations */\nvoid ppc_cache_operations(void) {\n    /* Clean cache lines for sensor system */\n    for (uint32_t addr = (uint32_t)&ppc_sensor_system; \n         addr < (uint32_t)&ppc_sensor_system + sizeof(ppc_sensor_system_t); \n         addr += PPC_CACHE_LINE_SIZE) {\n        \n        /* PowerPC e500 cache clean operation */\n        PPC_DCBF(0, (void*)addr);\n    }\n    \n    /* Synchronize cache operations */\n    PPC_SYNC();\n    \n    /* Instruction synchronization barrier */\n    PPC_ISYNC();\n}\n\n/* PowerPC e500 TLB operations */\nvoid ppc_tlb_operations(void) {\n    /* Invalidate TLB entries for sensor data area */\n    uint32_t start_addr = (uint32_t)&ppc_sensor_system;\n    uint32_t end_addr = start_addr + sizeof(ppc_sensor_system_t);\n    \n    for (uint32_t addr = start_addr; addr < end_addr; addr += 4096U) {\n        /* PowerPC e500 TLB invalidate entry */\n        PPC_TLBIE(addr);\n    }\n    \n    /* TLB synchronization */\n    PPC_TLBSYNC();\n}\n\n/* PowerPC e500 system health monitoring */\nbool ppc_check_system_health(void) {\n    /* Check stack overflow */\n    if (ppc_check_stack_overflow()) {\n        return false;\n    }\n    \n    /* Check sensor system health */\n    if (!ppc_sensor_system.system_healthy) {\n        return false;\n    }\n    \n    /* Check memory pool health */\n    for (uint16_t i = 0; i < PPC_POOL_COUNT; i++) {\n        if (ppc_memory_pools[i].free_count == 0) {\n            return false;  /* All pools exhausted */\n        }\n    }\n    \n    return true;\n}\n\n/* PowerPC e500 main function with NASA compliance */\nint main(void) {\n    /* Initialize PowerPC e500 system */\n    ppc_initialize_system();\n    \n    /* Check initial system health */\n    if (!ppc_check_system_health()) {\n        return -1;  /* System initialization failed */\n    }\n    \n    /* Main system loop with bounded execution */\n    uint32_t loop_count = 0U;\n    const uint32_t MAX_LOOPS = 1000000U;  /* NASA Rule 2: Fixed upper bound */\n    \n    while (loop_count < MAX_LOOPS) {\n        /* Process all sensors */\n        ppc_process_all_sensors();\n        \n        /* Check system health periodically */\n        if (loop_count % 1000U == 0) {\n            if (!ppc_check_system_health()) {\n                break;  /* Exit on health failure */\n            }\n        }\n        \n        /* Interrupt-safe operations */\n        ppc_interrupt_safe_operation();\n        \n        /* Cache operations */\n        ppc_cache_operations();\n        \n        /* TLB operations */\n        ppc_tlb_operations();\n        \n        loop_count++;\n    }\n    \n    return (int)loop_count;\n}",
  "compliance_score": 99,
  "compliance_level": "fully_compliant",
  "violations": [],
  "annotations": {
    "function_count": 15,
    "line_count": 380,
    "complexity_score": 7,
    "nesting_depth": 4,
    "variable_count": 30,
    "pointer_count": 15,
    "loop_count": 4,
    "conditional_count": 20
  },
  "tags": ["powerpc_e500", "architecture_specific", "big_endian", "memory_pools", "tlb_operations"],
  "difficulty": "expert"
}
